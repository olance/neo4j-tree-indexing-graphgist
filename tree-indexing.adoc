= In-graph tree indexing

Storing tree structures in a graph database makes a lot of sense. However, some trees are easier to play with than others.
Some constraints will make things much more complicated. Ordered children for instance, or time-dependent hierarchies (a tree 
that changes in time), or ordered time-dependent hierarchies...

In this GraphGist, I will present tree indexing structures that make it easier to deal with that kind of trees and that would ultimately allow:

* Returning the full hierarchy with a single query, in a depth-first traversal fashion that allows building back the 
hierarchy in memory using your client language.
* Similarly, extracting the full subtree from a given node, with a single query.
* List direct children of any given node within the tree.

All of this for arbitrary depths of trees and with preservation of children order at each level in the returned data!

Please note that this document is as much a presentation as a personal research on in-graph tree indexing. It will progressively take you through several structures that all have their advantages and inconvenients. I think they could all be used successfully to work with trees, depending on your needs and constraints; I'll try to highlight the pros and cons for each of them.

== Let's start with a tree

Here's the tree we'll be working with:

//hide
//setup
[source,cypher]
----
CREATE (root:CATEGORIES {name: '1. Motorcycle Racing Categories'})

CREATE (root)-[:HAS]->(road:CATEGORY {name: '1.1 Road Racing'})
CREATE (road)-[:HAS]->(gp:SUBCATEGORY {name: '1.1.1 Grand Prix'})
CREATE (gp)-[:HAS]->(moto2:CLASS {name: '1.1.1.2 Moto2'})
CREATE (gp)-[:HAS]->(moto3:CLASS {name: '1.1.1.1 Moto3'})
CREATE (gp)-[:HAS]->(motogp:CLASS {name: '1.1.1.3 MotoGP'})

CREATE (road)-[:HAS]->(tradi:SUBCATEGORY {name: '1.1.6 Traditional'})
CREATE (road)-[:HAS]->(ssp:SUBCATEGORY {name: '1.1.3 Supersport'})
CREATE (road)-[:HAS]->(sbk:SUBCATEGORY {name: '1.1.2 Superbike'})
CREATE (road)-[:HAS]->(sidecar:SUBCATEGORY {name: '1.1.5 Sidecar'})
CREATE (road)-[:HAS]->(endurance:SUBCATEGORY {name: '1.1.4 Endurance'})

CREATE (root)-[:HAS]->(cross:CATEGORY {name: '1.2 Motocross'})
CREATE (cross)-[:HAS]->(supermoto:SUBCATEGORY {name: '1.2.2 Supermoto'})
CREATE (cross)-[:HAS]->(supercross:SUBCATEGORY {name: '1.2.1 Supercross'})

RETURN *
----

_Note: Nodes have been created in random order to ensure subsequent queries do not return ordered nodes "by accident"_

// graph

As you probably can see, order is important in this tree. If we wanted to display the complete hierarchy of motorcycle racing categories as a plan for an article (just as it's done in http://en.wikipedia.org/wiki/Motorcycle_racing#Motorcycle_Grand_Prix[this wikipedia article] the data's been taken from), we'd probably love to query the whole tree and have nothing more to do than display it, confident that items will be in correct order.

The problem with such a graph is that all the order information is lost: the `:HAS` relationships do not allow us to retrieve the children of a node in order. +
What about storing the position  of each child in its `:HAS` relationship? Something like this:

[source,cypher]
------
// Match all :HAS relationships and the child they point to
MATCH ()-[r:HAS]->(child)

// 1. Split child name by spaces: "1.1.1.3 MotoGP" => ["1.1.1.3", "MotoGP"]
// 2. Split first item by dots and take last: "1.1.1.3" => "3"
// 3. Convert to Int and store in relationship's `pos` property
SET r.pos = toInt(last(split(head(split(child.name, ' ')), '.')))
RETURN r
------

// table

_Note: this query works here because we had the position in each node's label, you would of course need to come up with your own algorithm to build your tree with the correct `pos` property on each relationship_

Now that we have this position property on each relationship, we can effectively get the ordered children of a given node:

[source,cypher]
------
MATCH (root {name: '1.1.1 Grand Prix'})-[r:HAS]->(child)
RETURN child
ORDER BY r.pos
------

// table

What if we want to get the whole tree? We can use a variable-length relationships syntax to do that:

[source,cyper]
-------
MATCH p= (root:CATEGORIES)-[r:HAS*0..]->(child)
RETURN p,r
-------

// table

The problem is that we do get the complete tree as a result of that kind of query, but it's going to be very difficult to deal with the relationships collections represented by `r` and the paths represented by `p` to return a list of nodes that can be easily used to build back the tree later on (I'm assuming we want to do as less operations as possible on the client side).
